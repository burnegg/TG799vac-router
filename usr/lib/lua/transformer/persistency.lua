--- The persistency interface for transformer

-- NOTE:
--   Several functions take an ireferences parameter. The ireferences is a table
--   with a combination of instance numbers (as specified in TR-106 and generated by
--   Transformer) and instance names (pass through values). The ireferences table
--   should contain the instance references in reverse order.
--   So ireferences[1] refers to the deepest level in the tree.

-- NOTE:
--   All functions manipulating the database will throw an error if they
--   fail in unexpected ways.
--   If errors are reported they are errors that can be expected to happen.
--   (eg duplicate keys on insert)

local M = {}

local require, tostring, pairs, ipairs, setmetatable, type, next =
      require, tostring, pairs, ipairs, setmetatable, type, next
local format = string.format
local concat = table.concat

local db = require("transformer.persistency.db")
local logger = require("transformer.logger").new('DB')
local pathFinder = require("transformer.pathfinder")
local fault = require("transformer.fault")

local stripEnd,            stripEndNoTrailingDot =
      pathFinder.stripEnd, pathFinder.stripEndNoTrailingDot
local isMultiInstance,            endsWithPassThroughPlaceholder =
      pathFinder.isMultiInstance, pathFinder.endsWithPassThroughPlaceholder

local Persistency={}

--- Create a database string representing the instance references.
-- @param #table ireferences A table containing the instance references in
--                           reverse order.
-- @return #string A string representation for the instance references that can
--                 be used by the database.
local function string_from_ireferences(ireferences)
  if ireferences then
    return concat(ireferences, '.')
  else
    return ""
  end
end

--- Transform a database instance references string to the corresponding
-- instance references table.
-- @param #string s The string representation for the instance references.
-- @return #table A table containing the instance references in reverse order.
local function ireferences_from_string(s)
  local ireferences = {}
  for f in s:gmatch("([^.]*).?") do
    -- the last match will be an empty string
    if f ~= "" then
      ireferences[#ireferences+1] = f
    end
  end
  return ireferences
end

--- Append an instance reference to a ireferences string
-- @param #string iref The ireferences as a database string.
-- @param #string instance The instance reference to add.
-- @return #string The correct database string that will result in the correct ireferences
--    table when converted later on.
local function string_append_instance(iref, instance)
  if #iref>0 then
    return instance.."."..iref
  end
  return instance
end

--- Get the DB entry corresponding to the given type path and instance references.
-- @param #table db The database object.
-- @param #string typepath The type path of the object.
-- @param #string iref The instance references string for the object.
-- @return #table The actual database row if the object is found,
--    nil otherwise.
-- If the type path is single instance it is added to the database if needed.
local function getObject(db, typepath, iref)
  local obj = db:getObject(typepath, iref)
  if obj==nil then
    -- the object does not exist in the database yet
    -- if the type path indicates single instance, we can add it
    -- for multi instance this is an error (handled by the caller)
    local first, last = stripEndNoTrailingDot(typepath)
    if #last > 0 and not isMultiInstance(last) then
      -- This is a single instance, find the parent
      local parent
      if first~="" then
        parent = getObject(db, first, iref)
        -- if parent is nil here, this signals an error
        -- the parent could not be located.
      else
        -- type path is the top level (eg Device.) so there is no
        -- parent
        parent = {}
      end
      if parent~=nil then
        -- we found a parent object, so we can insert the given
        -- type path in the database
        -- as it is single instance, it inherits the key of first
        -- multi-instance parent (if any)
        obj = db:insertObject(typepath, iref, parent.key or "", parent.id)
      end
    end
  end
  return obj
end

--- Get the parent database object for a given multi instance type path and given
-- instance references.
-- @param #table db The database object.
-- @param #string typepath The type path, must be multi-instance.
-- @param #string iref The instance references as a string.
-- @return #table, #string The database object of the parent and the child part of the
--                         type path or nil if not found.
local function getParentOfMulti(db, typepath, iref)
  local first, last, placeHolder
  first, placeHolder = stripEndNoTrailingDot(typepath)
  assert(isMultiInstance(placeHolder), "path must be multi instance")
  first, last = stripEnd(first)

  local ppath = first
  local child = last..placeHolder.."." --Add the trailing dot again
  local parent = getObject(db, ppath, iref)

  return parent, child
end

--- Helper function to add an entry to the database.
-- @param #table db The database object.
-- @param #string cpath The child portion of the type path.
-- @param #string iref_parent The instance references string of the parent object.
-- @param #string typepath The type path of the object.
-- @param #string key The key of the object.
-- @param #number parent_db_id The database id of the parent object.
-- @param #boolean keyIsTable Indicates if the given key is a table or a string.
-- @return #string The generated instance reference. Throws an error if something goes wrong.
local function addInstance(db, cpath, iref_parent, typepath, key, parent_db_id, keyIsTable)
  -- generate the new instance number
  logger:debug("addInstance: %s, %s, %d", cpath, typepath, parent_db_id)
  local endsWithTransformed = (not endsWithPassThroughPlaceholder(cpath))
  local instance
  local actual_key = key
  if endsWithTransformed then
    instance = db:getCount(parent_db_id, cpath)+1
    instance = tostring(instance) -- We want the instance reference to be a string.
  else
    if keyIsTable then
      instance = key[1]
      actual_key = key[2]
    else
      instance = key
    end
  end

  if instance then
    -- generate the instance references string for the object
    local refs = string_append_instance(iref_parent, instance)
    -- insert it in the db
    local obj, msg = db:insertObject( typepath,
                                    refs,
                                    actual_key,
                                    parent_db_id)
    if obj==nil then
      local err_msg = format("database: %s, typepath='%s', ireferences='%s', key='%s'", msg, typepath, refs, actual_key)
      logger:error(err_msg)
      fault.InternalError(err_msg);
    end
    if endsWithTransformed then
      -- store the instance number in count
      -- we do it here just in case we are not in a transaction. The insert
      -- succeeded so we do not leave a hole in the numbering.
      db:setCount(parent_db_id, cpath, instance)
    end
    return instance
  end
  -- No instance, throw error
  fault.InternalError("Persistency: no instance to add!");
end

--- Get the key of the given type path and instance references.
-- @param #string typepath The full type path of the object.
-- @param #table ireferences The table with all instance references.
-- @return #string The key stored in the database if it exists or nil.
function Persistency:getKey(typepath, ireferences)
  local key
  local iref = string_from_ireferences(ireferences)
  local obj = self._db:getObject(typepath, iref)
  if obj then
    key = obj.key
  end
  return key
end

--- Get the ireferences of the given type path and key.
-- @param #string typepath The full type path of the object.
-- @param #string key The key of the object.
-- @return #table The ireferences table stored in the database if it exists or nil.
function Persistency:getIreferences(typepath, key)
  local ireferences
  local obj = self._db:getObjectByKey(typepath, key)
  if obj then
    ireferences = ireferences_from_string(obj.ireferences)
  end
  return ireferences
end

--- Add an entry to the database.
-- @param #string typepath The type path of the object to add.
-- @param #table ireferences_parent The instance references of the parent object.
-- @param #string or #table key The key of the object.
-- @return #string The assigned instance reference or nil in case of error.
function Persistency:addKey(typepath, ireferences_parent, key)
  local db = self._db
  local iref = string_from_ireferences(ireferences_parent)
  local parent, cpath = getParentOfMulti(db, typepath, iref)
  assert(parent, "a parent does not exist")

  -- Check if the given key is a string or a table.
  local keysTuples = false
  if type(key) == "table" then
    keysTuples = true
  end

  return addInstance(db, cpath, iref, typepath, key, parent.id, keysTuples)
end

--- Delete an entry from the database.
-- @param #string typepath The type path of the object.
-- @param #table ireferences The instance references of the object.
-- @return nil
function Persistency:delKey(typepath, ireferences)
  local iref = string_from_ireferences(ireferences)
  self._db:deleteObject(typepath, iref)
end

local function query_keys_impl(db, typepath, level)
  local keys = {}
  if level < 1 then
    return keys
  end
  -- We need to find the first level of multi-instance before we can iterate.
  local first, placeHolder = stripEndNoTrailingDot(typepath)
  while placeHolder~="" and not isMultiInstance(placeHolder) do
    typepath = first
    first, placeHolder = stripEndNoTrailingDot(typepath)
  end
  if not placeHolder or placeHolder == "" then
    -- typepath is a root path or contains no multi-instance levels.
    return keys
  end
  -- typepath now points to the lowest multi-instance level, populate keys
  -- with all entries of this level.
  local level_keys = db:getSiblings(typepath)
  if not level_keys or next(level_keys) == nil then
    -- There are no entries found on this level, no point in looking further.
    return keys
  end

  for i, row in ipairs(level_keys) do
    keys[i] = { key = {row.key}, nextparent = row.parent}
  end
  -- We found a level, decrease
  level = level - 1

  while level > 0 do
    -- We want more info, look for parents
    local parent_keys = db:getParents(typepath)
    if not parent_keys or #parent_keys == 0 then
      -- No parents found, no more multi-instance parents available.
      break
    end
    -- Parent entries found. Two possibilities:
    --    The parent typepath is single instance -> we need to look further
    --    The parent typepath is multi instance -> merge the keys
    local parent_typepath = parent_keys[1].typepath -- This should be the same for all parents.
    first, placeHolder = stripEndNoTrailingDot(parent_typepath)
    if not placeHolder or placeHolder == "" then
      -- Reached the root.
      break
    end
    -- If the parent is multi instance, we need to append the parent keys.
    local append_keys = true
    if not isMultiInstance(placeHolder) then
      -- Possibility 1: parent = single instance.
      -- Don't append the keys, just update the next parent keys.
      append_keys = false
    else
      -- Possibility 2
      level = level - 1
    end

    for _, row in ipairs(parent_keys) do
      -- Loop over the previously found keys and update and/or append.
      for _, found in ipairs(keys) do
        if found.nextparent == row.id then
          if append_keys then
            found.key[#found.key + 1] = row.key
          end
          -- Update the next parent key
          found.nextparent = row.parent
        end
      end
    end

    -- Level up
    typepath = parent_typepath
  end

  -- Only keep the key of every entry in the array
  for i, entry in pairs(keys) do
    keys[i] = entry.key
  end
  return keys
end

function Persistency:query_keys(typepath, level)
  if type(level) ~= "number" then
    level = 1
  end
  local ok, result = pcall(query_keys_impl, self._db, typepath, level)
  if not ok then
    -- log error and return empty table.
    logger:error(result)
    return {}
  end
  return result
end

-- the actual implementation of the sync
local function sync_impl(db, typepath, keys, ireferences_parent)
  local keymap = {}
  local iref = string_from_ireferences(ireferences_parent)

  local parent, child = getParentOfMulti(db, typepath, iref)
  assert(parent, "a parent does not exist")

  -- retrieve the objects currently in the database
  local db_objects = db:getChildren(parent.id, typepath)

  -- Check if the given keys are strings or tables.
  local keysTuples = false
  if keys and keys[1] and type(keys[1]) == "table" then
    keysTuples = true
  end

  -- build the result keymap by making sure all the given keys are in
  -- the database.
  for _, key in ipairs(keys) do
    local actual_key = key
    if keysTuples then
      actual_key = key[2]
    end
    local index = db_objects[actual_key]
    local instance
    if index then
      local obj = db_objects[index]
      -- the key is present in the database
      -- remove it from the db_object table to mark it as processed
      -- and present.
      db_objects[index] = nil
      db_objects[actual_key] = nil

      -- extract the instance reference at this level
      local inst = ireferences_from_string(obj.ireferences)
      instance = inst[1]
    else
      -- addInstance will either succeed or throw an error.
      instance = addInstance(db, child, iref, typepath, key, parent.id, keysTuples)
    end
    if instance then
      keymap[instance] = actual_key
    end
  end

  -- whatever objects remain in the database list, do no longer exist
  -- in reality.
  -- remove them from the database.
  for _, obj in pairs(db_objects) do
    if type(obj)=='table' then
      db:deleteObject(obj.typepath, obj.ireferences)
    end
  end

  return keymap
end

--- Synchronize the database for the given type path.
-- @param #string typepath The type path to update (must be multi-instance).
-- @param #table keys A list of keys for all lower layer objects.
-- @param #table ireferences_parent The instance reference array for the parent object (this could
--                       be empty)
-- @return #table A mapping of all instance numbers on this level to the
-- given keys.
-- The database is updated to match this state
-- in case of a constraint violation the function returns nil and the database
-- is not changed.
function Persistency:sync(typepath, keys, ireferences_parent)
  local db = self._db
  local result

  -- wrap the sync_impl call in a transaction to handle the error case.
  -- We don't know if this is the outer transaction, so create an inner one
  -- to be safe.
  local savepoint = db:startTransaction(false)
  local ok
  ok, result = pcall(sync_impl, db, typepath, keys, ireferences_parent)
  local commit = ok and result
  if commit then
    db:commitTransaction(savepoint)
  else
    db:rollbackTransaction(savepoint)
  end
  if not ok then
    -- propagate error
    error(result)
  end
  return result
end

function Persistency:close()
  self._db:close()
  self._db = nil
end

--- Start a transaction on database level.
-- NOTE: This should be followed by either a call to commit or
--       a call to revert. Calling this function again before
--       commit or revert has been called will result in an error.
function Persistency:startTransaction()
  self._db:startTransaction(true)
end

--- Commit a transaction on database level.
-- NOTE: This should only be called when a transaction is in progress,
--       otherwise this function will raise an error. Any sub-transactions
--       will also be committed.
function Persistency:commitTransaction()
  self._db:commitTransaction()
end

--- Revert a transaction on database level.
-- NOTE: This should only be called when a transaction is in progress,
--       otherwise this function will raise an error. Any sub-transactions
--       will also be reverted.
function Persistency:revertTransaction()
  self._db:rollbackTransaction()
end

Persistency.__index = Persistency
function M.new(dbpath, dbname)
  local p={
    _db = db.new(dbpath, dbname);
  }

  return setmetatable(p, Persistency)
end

return M
